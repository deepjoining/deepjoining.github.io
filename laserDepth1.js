  function myFunction1() {

    var x = document.getElementById("power1ID").value;
    var y = document.getElementById("speed1ID").value;
    var z = document.getElementById("diameter1ID").value;

    var depth = myNeuralNetworkFunction1(x,y,z);
    document.getElementById("print1").innerHTML = "Estimated Depth is " + depth.toFixed(2) + " mm";
    
  }

  function myNeuralNetworkFunction1(x1,x2,x3)
{
  var xp1_idx_0;
  var xp1_idx_1;
  var xp1_idx_2;
  var a;
  var k;

  const b_a = [-1.3665907585173613, 2.3934762276561519,
    -0.054889451631298089, 1.3123087433438565, 0.074529810187357645 ];

  const c_a = [ 0.89533453786943862, -6.83720524011001,
    1.0141794573506049, 3.1110224835240805, 1.5345300749697304 ];

  const d_a = [-0.42764460976660718, 0.63514467891465609,
    0.50482103334440609, 1.8740110140944313, 3.322303846497118,
    0.62103942988523986, -5.9739466559914076, -2.5849941742019498,
    0.57493038088159487, -1.0949516893950242, 0.18460805588707713,
    0.19567342401305038, 2.0575371894627876, 0.14815306323163113,
    -1.1398614501961182 ];
  /* MYNEURALNETWORKFUNCTION neural network simulation function. */
  /*  */
  /*  Auto-generated by MATLAB, 06-Jun-2021 13:49:42. */
  /*  */
  /*  [y1] = myNeuralNetworkFunction(x1) takes these arguments: */
  /*    x = Qx3 matrix, input #1 */
  /*  and returns: */
  /*    y = Qx1 matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  xp1_idx_0 = (x1 - 0.3) * 0.121951219512195 + -1.0;
  xp1_idx_1 = (x2 - 0.27930174563591) * 0.101287455393338 + -1.0;
  xp1_idx_2 = (x3 - 0.05) * 2.73972602739726 + -1.0;

  /*  Layer 1 */
  /*  Sigmoid Symmetric Transfer Function */
  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  a = 0.0;
  for (k = 0; k < 5; k++) {
    a += b_a[k] * (2.0 / (1.0 + Math.exp(-2.0 * (c_a[k] + ((d_a[k] * xp1_idx_0 +
      d_a[k + 5] * xp1_idx_1) + d_a[k + 10] * xp1_idx_2)))) - 1.0);
  }

  return ((1.5297887196801656 + a) - -1.0) / 0.132931762032067 +
    0.192691104407987;
}
