  function myFunction3() {

  var size = 100, x = new Array(size), y = new Array(size), z = new Array(size), i, j;
  var power = document.getElementById("power3ID").value;

  var stringPower = '' + power;
  
  for(var i = 0; i < size; i++) {
	  x[i] = 1. + 6.1*i/size;
    y[i] = 0.1 + 0.61*i/size;
  	z[i] = new Array(size);
  }

  for(var i = 0; i < size; i++) {
  	for(j = 0; j < size; j++) {
    	z[i][j] = myNeuralNetworkFunction3(power,x[j],y[i]);
 	  }
  }

  var  layout = {                     // all "layout" attributes: #layout
        title: 'Laser power: '+ stringPower+ ' kW',  // more about "layout.title": #layout-title
        xaxis: {                  // all "layout.xaxis" attributes: #layout-xaxis
            title: 'Welding speed (m/min)'         // more about "layout.xaxis.title": #layout-xaxis-title
        },
        yaxis: {                  // all "layout.xaxis" attributes: #layout-xaxis
            title: 'Beam diamter (mm)'         // more about "layout.xaxis.title": #layout-xaxis-title
        },

  }
  var data = [ {
	  	z: z,
	  	x: x,
	  	y: y,
	  	type: 'contour',
      colorbar: {title: {text: 'depth in mm'}},
	  }
  ];

Plotly.newPlot('myDiv', data, layout);
}

function myNeuralNetworkFunction3(x1,x2,x3)
{
  var xp1_idx_0;
  var xp1_idx_1;
  var xp1_idx_2;
  var a;
  var k;

  const b_a = [-1.3665907585173613, 2.3934762276561519,
    -0.054889451631298089, 1.3123087433438565, 0.074529810187357645 ];

  const c_a = [ 0.89533453786943862, -6.83720524011001,
    1.0141794573506049, 3.1110224835240805, 1.5345300749697304 ];

  const d_a = [-0.42764460976660718, 0.63514467891465609,
    0.50482103334440609, 1.8740110140944313, 3.322303846497118,
    0.62103942988523986, -5.9739466559914076, -2.5849941742019498,
    0.57493038088159487, -1.0949516893950242, 0.18460805588707713,
    0.19567342401305038, 2.0575371894627876, 0.14815306323163113,
    -1.1398614501961182 ];
  /* MYNEURALNETWORKFUNCTION neural network simulation function. */
  /*  */
  /*  Auto-generated by MATLAB, 06-Jun-2021 13:49:42. */
  /*  */
  /*  [y1] = myNeuralNetworkFunction(x1) takes these arguments: */
  /*    x = Qx3 matrix, input #1 */
  /*  and returns: */
  /*    y = Qx1 matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  xp1_idx_0 = (x1 - 0.3) * 0.121951219512195 + -1.0;
  xp1_idx_1 = (x2 - 0.27930174563591) * 0.101287455393338 + -1.0;
  xp1_idx_2 = (x3 - 0.05) * 2.73972602739726 + -1.0;

  /*  Layer 1 */
  /*  Sigmoid Symmetric Transfer Function */
  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  a = 0.0;
  for (k = 0; k < 5; k++) {
    a += b_a[k] * (2.0 / (1.0 + Math.exp(-2.0 * (c_a[k] + ((d_a[k] * xp1_idx_0 +
      d_a[k + 5] * xp1_idx_1) + d_a[k + 10] * xp1_idx_2)))) - 1.0);
  }

  return ((1.5297887196801656 + a) - -1.0) / 0.132931762032067 +
    0.192691104407987;
}
